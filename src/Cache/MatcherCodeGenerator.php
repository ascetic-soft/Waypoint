<?php

declare(strict_types=1);

namespace AsceticSoft\Waypoint\Cache;

use AsceticSoft\Waypoint\Route;

/**
 * Generates the compiled PHP matcher class as a string.
 *
 * Uses a **named PHP class** so that PHP opcache can cache:
 * - the class definition (bytecode) in shared memory,
 * - class constants (ROUTES, TRIE, STATIC_TABLE, etc.) as immutable arrays
 *   in opcache shared memory — zero per-request allocation.
 *
 * A `class_exists` guard ensures the class is defined only once per process,
 * so subsequent `include` calls (same worker) skip class definition entirely
 * and just return `new ClassName()` — near-zero per-request cost.
 */
final class MatcherCodeGenerator
{
    /**
     * Generate the compiled matcher PHP code.
     *
     * @param list<array<string, mixed>> $routeData       Compact route data for each route.
     * @param array<string, mixed>       $trieArray       Serialised trie (from RouteTrie::toArray).
     * @param list<int>                  $fallbackIndices Non-trie-compatible route indices.
     * @param array<string, int>         $staticTable     method:uri → route index.
     * @param array<string, true>        $staticOnlyUris  URIs that can only match via the static table.
     */
    public function generate(
        array $routeData,
        array $trieArray,
        array $fallbackIndices,
        array $staticTable,
        array $staticOnlyUris,
    ): string {
        // Content-based hash → unique class name per route set (avoids stale
        // definitions when the cache is regenerated in the same process).
        $hash = substr(hash('xxh128', serialize($routeData)), 0, 16);
        $className = "WaypointCompiledMatcher_$hash";

        // Build name index (name → route index).
        $nameIndex = [];
        foreach ($routeData as $index => $data) {
            $name = $data['n'] ?? '';
            if (\is_string($name) && $name !== '' && !isset($nameIndex[$name])) {
                $nameIndex[$name] = $index;
            }
        }

        // Build URI → allowed methods map (for 405 on static routes).
        $uriMethods = [];
        foreach ($staticTable as $key => $index) {
            [$method, $uri] = explode(':', $key, 2);
            $uriMethods[$uri][] = $method;
        }

        // ── Emit PHP ──
        $code = "<?php\n\n";
        $code .= "// Auto-generated by Waypoint RouteCompiler. Do not edit.\n\n";
        $code .= "if (!\\class_exists('{$className}', false)) {\n\n";
        $code .= "class $className implements \\AsceticSoft\\Waypoint\\Cache\\CompiledMatcherInterface\n{\n";

        $code .= $this->emitConstants($routeData, $staticTable, $uriMethods, $trieArray, $fallbackIndices, $nameIndex, $staticOnlyUris);
        $code .= $this->emitMethods(\count($routeData));

        $code .= "}\n\n"; // end class
        $code .= "}\n\n"; // end if (!class_exists)
        $code .= "return new $className();\n";

        return $code;
    }

    // ── Static-only URI analysis ─────────────────────────────

    /**
     * Determine which static route URIs can only be matched via the static table.
     *
     * A static URI qualifies as "static-only" when:
     *  1. No parameterised trie child exists at any depth along the URI's path
     *     (otherwise a dynamic route could match the same URI).
     *  2. No fallback (non-trie-compatible) route regex matches the URI
     *     (otherwise a fallback route could match it).
     *
     * @param array<string, mixed> $trieArray       Serialised trie.
     * @param array<string, int>   $staticTable     method:uri → route index.
     * @param list<Route>          $allRoutes       All routes (compiled).
     * @param list<int>            $fallbackIndices Non-trie-compatible route indices.
     *
     * @return array<string, true>  Set of purely-static URIs.
     */
    public function computeStaticOnlyUris(
        array $trieArray,
        array $staticTable,
        array $allRoutes,
        array $fallbackIndices,
    ): array {
        // Collect unique URIs from the static table.
        $staticUris = [];
        foreach ($staticTable as $key => $idx) {
            [, $uri] = explode(':', $key, 2);
            $staticUris[$uri] = true;
        }

        $result = [];

        foreach ($staticUris as $uri => $_) {
            // Check 1: no param children along the trie path for this URI.
            if (!$this->hasNoParamChildrenAlongPath($trieArray, $uri)) {
                continue;
            }

            // Check 2: no fallback route matches this URI.
            $matchesFallback = false;
            foreach ($fallbackIndices as $idx) {
                if ($allRoutes[$idx]->match($uri) !== null) {
                    $matchesFallback = true;

                    break;
                }
            }

            if (!$matchesFallback) {
                $result[$uri] = true;
            }
        }

        return $result;
    }

    // ── Private helpers ─────────────────────────────────────────

    /**
     * Emit class constant declarations.
     *
     * @param list<array<string, mixed>>  $routeData
     * @param array<string, int>          $staticTable
     * @param array<string, list<string>> $uriMethods
     * @param array<string, mixed>        $trieArray
     * @param list<int>                   $fallbackIndices
     * @param array<string, int>          $nameIndex
     * @param array<string, true>         $staticOnlyUris
     */
    private function emitConstants(
        array $routeData,
        array $staticTable,
        array $uriMethods,
        array $trieArray,
        array $fallbackIndices,
        array $nameIndex,
        array $staticOnlyUris,
    ): string {
        $code = "    /** @var list<array<string, mixed>> Compact route data. */\n";
        $code .= "    private const ROUTES = [\n";
        foreach ($routeData as $index => $data) {
            $code .= \sprintf("        %d => %s,\n", $index, self::exportValue($data));
        }
        $code .= "    ];\n\n";

        $code .= \sprintf("    /** @var array<string, int> method:uri → route index. */\n");
        $code .= \sprintf("    private const STATIC_TABLE = %s;\n\n", self::exportValue($staticTable));

        $code .= \sprintf("    /** @var array<string, list<string>> uri → allowed methods. */\n");
        $code .= \sprintf("    private const URI_METHODS = %s;\n\n", self::exportValue($uriMethods));

        $code .= "    /** @var array<string, mixed> Serialised prefix trie. */\n";
        $code .= \sprintf("    private const TRIE = %s;\n\n", self::exportValue($trieArray));

        $code .= \sprintf("    /** @var list<int> Non-trie-compatible route indices. */\n");
        $code .= \sprintf("    private const FALLBACK = %s;\n\n", self::exportValue($fallbackIndices));

        $code .= \sprintf("    /** @var array<string, int> name → route index. */\n");
        $code .= \sprintf("    private const NAME_INDEX = %s;\n\n", self::exportValue($nameIndex));

        $code .= \sprintf("    /** @var array<string, true> URIs that can only match via the static table (no dynamic/fallback overlap). */\n");
        $code .= \sprintf("    private const STATIC_ONLY_URIS = %s;\n\n", self::exportValue($staticOnlyUris));

        return $code;
    }

    /**
     * Emit method implementations for the compiled matcher class.
     */
    private function emitMethods(int $routeCount): string
    {
        $code = '';

        // ── matchStatic — O(1) hash table lookup via const array ──
        $code .= "    public function matchStatic(string \$method, string \$uri): ?array\n";
        $code .= "    {\n";
        $code .= "        \$key = \$method . ':' . \$uri;\n";
        $code .= "        return isset(self::STATIC_TABLE[\$key]) ? [self::STATIC_TABLE[\$key], []] : null;\n";
        $code .= "    }\n\n";

        // ── staticMethods — for 405 responses ──
        $code .= "    public function staticMethods(string \$uri): array\n";
        $code .= "    {\n";
        $code .= "        return self::URI_METHODS[\$uri] ?? [];\n";
        $code .= "    }\n\n";

        // ── isStaticOnly — early 405 guard ──
        $code .= "    public function isStaticOnly(string \$uri): bool\n";
        $code .= "    {\n";
        $code .= "        return isset(self::STATIC_ONLY_URIS[\$uri]);\n";
        $code .= "    }\n\n";

        // ── matchDynamic — data-driven trie traversal ──
        $code .= "    public function matchDynamic(string \$method, string \$uri, array &\$allowedMethods = []): ?array\n";
        $code .= "    {\n";
        $code .= "        \$path = ltrim(\$uri, '/');\n";
        $code .= "        \$segments = \$path === '' ? [] : explode('/', \$path);\n";
        $code .= "        return \$this->walk(self::TRIE, \$method, \$segments, \\count(\$segments), 0, [], \$allowedMethods);\n";
        $code .= "    }\n\n";

        // ── walk — generic trie traversal ──
        $code .= "    /** @param array<string, mixed> \$node */\n";
        $code .= "    private function walk(array \$node, string \$m, array \$s, int \$n, int \$d, array \$p, array &\$am): ?array\n";
        $code .= "    {\n";
        $code .= "        if (\$d === \$n) {\n";
        $code .= "            foreach (\$node['routes'] ?? [] as \$idx) {\n";
        $code .= "                if (\\in_array(\$m, self::ROUTES[\$idx]['M'], true)) {\n";
        $code .= "                    return [\$idx, \$p];\n";
        $code .= "                }\n";
        $code .= "                foreach (self::ROUTES[\$idx]['M'] as \$method) {\n";
        $code .= "                    \$am[\$method] = true;\n";
        $code .= "                }\n";
        $code .= "            }\n";
        $code .= "            return null;\n";
        $code .= "        }\n";
        $code .= "        \$seg = \$s[\$d];\n";
        // Static child — hash lookup
        $code .= "        if (isset(\$node['static'][\$seg])) {\n";
        $code .= "            \$r = \$this->walk(\$node['static'][\$seg], \$m, \$s, \$n, \$d + 1, \$p, \$am);\n";
        $code .= "            if (\$r !== null) { return \$r; }\n";
        $code .= "        }\n";
        // Param children — regex
        $code .= "        foreach (\$node['param'] ?? [] as \$child) {\n";
        $code .= "            if (preg_match(\$child['regex'], \$seg)) {\n";
        $code .= "                \$r = \$this->walk(\$child['node'], \$m, \$s, \$n, \$d + 1, \$p + [\$child['paramName'] => \$seg], \$am);\n";
        $code .= "                if (\$r !== null) { return \$r; }\n";
        $code .= "            }\n";
        $code .= "        }\n";
        $code .= "        return null;\n";
        $code .= "    }\n\n";

        // ── getRoute — simple const access ──
        $code .= "    public function getRoute(int \$idx): array\n";
        $code .= "    {\n";
        $code .= "        return self::ROUTES[\$idx];\n";
        $code .= "    }\n\n";

        // ── getRouteCount ──
        $code .= "    public function getRouteCount(): int\n";
        $code .= "    {\n";
        $code .= \sprintf("        return %d;\n", $routeCount);
        $code .= "    }\n\n";

        // ── getFallbackIndices ──
        $code .= "    public function getFallbackIndices(): array\n";
        $code .= "    {\n";
        $code .= "        return self::FALLBACK;\n";
        $code .= "    }\n\n";

        // ── findByName — O(1) const array lookup ──
        $code .= "    public function findByName(string \$name): ?int\n";
        $code .= "    {\n";
        $code .= "        return self::NAME_INDEX[\$name] ?? null;\n";
        $code .= "    }\n";

        return $code;
    }

    /**
     * Walk the serialised trie along a URI's segments and check that no
     * parameterised children exist at any intermediate depth.
     *
     * @param array<string, mixed> $trieNode Root trie node.
     * @param string               $uri      Static URI (e.g. "/about").
     */
    private function hasNoParamChildrenAlongPath(array $trieNode, string $uri): bool
    {
        $path = ltrim($uri, '/');
        $segments = $path === '' ? [] : explode('/', $path);

        /** @var array{static: array<string, mixed>, param: list<mixed>, routes: list<int>} $node */
        $node = $trieNode;

        foreach ($segments as $segment) {
            if ($node['param'] !== []) {
                return false;
            }

            /** @var array<string, array{static: array<string, mixed>, param: list<mixed>, routes: list<int>}> $staticChildren */
            $staticChildren = $node['static'];

            if (!isset($staticChildren[$segment])) {
                // @codeCoverageIgnoreStart
                return false;
                // @codeCoverageIgnoreEnd
            }

            $node = $staticChildren[$segment];
        }

        return true;
    }

    /**
     * Export a PHP value as compact code (short array syntax, minimal whitespace).
     */
    private static function exportValue(mixed $value): string
    {
        if ($value === null) {
            return 'null';
        }

        if ($value === true) {
            return 'true';
        }

        if ($value === false) {
            return 'false';
        }

        if (\is_int($value) || \is_float($value)) {
            return (string) $value;
        }

        if (\is_string($value)) {
            return var_export($value, true);
        }

        if (\is_array($value)) {
            if ($value === []) {
                return '[]';
            }

            $isList = array_is_list($value);
            $parts = [];

            foreach ($value as $k => $v) {
                if ($isList) {
                    $parts[] = self::exportValue($v);
                } else {
                    $parts[] = self::exportValue($k) . ' => ' . self::exportValue($v);
                }
            }

            return '[' . implode(', ', $parts) . ']';
        }

        // @codeCoverageIgnoreStart
        return var_export($value, true);
        // @codeCoverageIgnoreEnd
    }
}
